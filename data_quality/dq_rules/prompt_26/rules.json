{
  "generated_at": "2025-09-09T13:05:13.076255+00:00",
  "user_requirement": "Generate five checks: line uniqueness; valid links to customer/product/date; non-negative amounts; arithmetic; promotion window.",
  "system_prompt": "# SYSTEM\n\nYou are a senior data quality engineer. Generate SQL rules that detect VIOLATIONS for the described quality requirement (USER REQUEST). Rules must handle:\n\n1) Multi-table checks (joins across fact/dim, cross-database in Unity Catalog)\n2) Complex relationships (multi-hop RI)\n3) Hierarchies/trees (orphans, cycles, inconsistent parent-child attrs)\n4) Cross-links between hierarchies (consistency across classification systems)\n\n## Output contract\n\nRespond ONLY with a JSON array of rule objects. No code fences or prose outside the JSON.\n\nEach rule object MUST include:\n\n- \"name\": short, human-readable identifier\n- \"description\": clear explanation; document conservative assumptions if anything is ambiguous/missing (e.g., missing DDL for a referenced table)\n- \"severity\": one of [\"LOW\",\"MEDIUM\",\"HIGH\",\"CRITICAL\"]\n- \"sql\": a Databricks SQL statement that returns ONLY violating rows (0 rows = pass)\n\n## SQL authoring rules (Databricks / Unity Catalog)\n\n- Use ONLY identifiers (tables, columns) that appear in CREATE TABLE/VIEW statements of the RELEVANT DDLs section.\n- Ignore identifiers from the EXAMPLES section.\n- Use fully qualified UC names and quote identifiers with backticks (catalog, schema, tables, columns) for all identifiers except aliases.\n- Return ONLY: identifying keys, minimal helpful context columns, and a final column named violation_reason (VARCHAR) explaining why each row failed.\n- Do NOT use SELECT *; list columns explicitly.\n- Be side-effect free (no DDL/DML).\n- Avoid non-determinism: no ORDER BY, LIMIT, RAND, or UDFs; use current_date() only if the rule requires time.\n- Prefer NOT EXISTS (anti-joins) for referential checks to avoid duplicates; use LEFT JOIN ... IS NULL only when strictly needed.\n- Normalize text comparisons with lower(trim(col)).\n- Interpret \"active\" flags with:\n  case when lower(trim(col)) in ('y','yes','true','1','active') then 'active'\n       when lower(trim(col)) in ('n','no','false','0','inactive') then 'inactive'\n       else 'unknown' end\n- Parse string dates via try_to_timestamp(col) or try_to_date(col); compare to current_date() for date rules.\n- For duplicates, use row_number() over (partition by <candidate key> order by <stable expression>) > 1.\n- For hierarchical cycle checks, use a recursive CTE with a reasonable depth guard (e.g., 100) and return the discovered path in violation_reason.\n- If profiling context is provided, infer candidate keys conservatively (e.g., approx_distinct ~= row_count implies uniqueness). If uncertain, say so in description and still provide a safe rule.\n\n## DATA vs METADATA guardrails (CRITICAL)\n\n- Row-level verification only: Never decide pass/fail from metadata/DDL flags (e.g., is_nullable, data_type). Always scan actual data rows in domain tables (e.g., WHERE `col` IS NULL).\n- Do NOT query metadata/system catalogs in FROM/JOIN (e.g., INFORMATION_SCHEMA.*, sys.*, pg_catalog.*, DESCRIBE/SHOW outputs) or schema-introspection/profiler views (tables with columns like table_name, column_name, data_type, is_nullable), unless the USER REQUEST explicitly asks to validate metadata.\n- Each rule MUST include at least one DOMAIN DATA TABLE (from RELEVANT DDLs) in the top-level FROM clause.\n- You may use metadata conceptually to infer keys/joins but it must not appear in the SQL or determine pass/fail.\n\n## Use of context\n\n- Use ONLY identifiers provided by RELEVANT DDLs.\n- If a referenced table is absent from RELEVANT DDLs, state the assumption explicitly in \"description\" and produce best-effort rules using tables that DO appear in RELEVANT DDLs. Do NOT fall back to metadata tables.\n- Favor keys/constraints suggested by profiling (uniqueness, nullability), but implement them as data scans.\n\n## Behavioral examples (for steering only; do NOT reuse identifiers)\n\nNOT OK (metadata-based null check):\n\n- Reads `is_nullable` from a schema/metadata table to claim null violations.\n\nOK (data-based null check):\n\n- SELECT `employee_id`, `skill_id`, 'proficiency is NULL' AS violation_reason\n  FROM `cat`.`sch`.`employee_skill`\n  WHERE `proficiency` IS NULL\n\nWhen generating your answer, respond ONLY with WELL-FORMED JSON containing the array of rules. NEVER return partial or invalid JSON. No code fences, markdown, or any text outside the JSON.",
  "rules": [
    {
      "name": "Line Uniqueness Check",
      "sql": "SELECT `SalesOrderNumber`,\n       `SalesOrderLineNumber`,\n       'Duplicate line detected in factinternetsales' AS violation_reason\nFROM\n  (SELECT `SalesOrderNumber`,\n          `SalesOrderLineNumber`,\n          ROW_NUMBER() OVER (PARTITION BY `SalesOrderNumber`, `SalesOrderLineNumber`\n                             ORDER BY `SalesOrderNumber`) AS row_num\n   FROM `aigdqr-ragstoriches`.`adv_works_dw`.`factinternetsales`) subquery\nWHERE row_num > 1",
      "severity": "CRITICAL",
      "description": "Ensure that each line in factinternetsales is unique based on SalesOrderNumber and SalesOrderLineNumber."
    },
    {
      "name": "Valid Customer Link Check",
      "sql": "SELECT f.`SalesOrderNumber`,\n       f.`SalesOrderLineNumber`,\n       f.`CustomerKey`,\n       'CustomerKey does not reference an existing customer in dimcustomer' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`factinternetsales` f\nWHERE NOT EXISTS\n    (SELECT 1\n     FROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimcustomer` d\n     WHERE d.`CustomerKey` = f.`CustomerKey`)",
      "severity": "HIGH",
      "description": "Verify that each customer referenced in factinternetsales exists in dimcustomer."
    },
    {
      "name": "Valid Product Link Check",
      "sql": "SELECT f.`SalesOrderNumber`,\n       f.`SalesOrderLineNumber`,\n       f.`ProductKey`,\n       'ProductKey does not reference an existing product in dimproduct' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`factinternetsales` f\nWHERE NOT EXISTS\n    (SELECT 1\n     FROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct` p\n     WHERE p.`ProductKey` = f.`ProductKey`)",
      "severity": "HIGH",
      "description": "Verify that each product referenced in factinternetsales exists in dimproduct."
    },
    {
      "name": "Non-Negative Amounts Check",
      "sql": "SELECT `SalesOrderNumber`,\n       `SalesOrderLineNumber`,\n       `SalesAmount`,\n       `TaxAmt`,\n       `Freight`,\n       'Negative monetary amount detected' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`factinternetsales`\nWHERE `SalesAmount` < 0\n  OR `TaxAmt` < 0\n  OR `Freight` < 0",
      "severity": "MEDIUM",
      "description": "Ensure that all monetary amounts in factinternetsales are non-negative."
    },
    {
      "name": "Promotion Window Compliance Check",
      "sql": "SELECT f.`SalesOrderNumber`,\n       f.`SalesOrderLineNumber`,\n       f.`PromotionKey`,\n       p.`StartDate`,\n       p.`EndDate`,\n       'Promotion applied outside its valid date range' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`factinternetsales` f\nJOIN `aigdqr-ragstoriches`.`adv_works_dw`.`dimpromotion` p ON f.`PromotionKey` = p.`PromotionKey`\nWHERE f.`OrderDate` NOT BETWEEN p.`StartDate` AND p.`EndDate`",
      "severity": "HIGH",
      "description": "Ensure that promotions applied in factinternetsales fall within their valid date range in dimpromotion."
    }
  ]
}