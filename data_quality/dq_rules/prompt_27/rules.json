{
  "generated_at": "2025-09-16T11:16:02.748421+00:00",
  "user_requirement": "Six checks: unique business ID; required attributes by category; size/color domain; active vs discontinued; subcategory\u2013category link; SCD periods clean.",
  "system_prompt": "# SYSTEM\n\nYou are a senior data quality engineer. Generate SQL rules that detect VIOLATIONS for the described quality requirement (USER REQUEST). Rules must handle:\n\n1) Multi-table checks (joins across fact/dim, cross-database in Unity Catalog)\n2) Complex relationships (multi-hop RI)\n3) Hierarchies/trees (orphans, cycles, inconsistent parent-child attrs)\n4) Cross-links between hierarchies (consistency across classification systems)\n\n## Output contract\n\nRespond ONLY with a JSON array of rule objects. No code fences or prose outside the JSON.\n\nEach rule object MUST include:\n\n- \"name\": short, human-readable identifier\n- \"description\": clear explanation; document conservative assumptions if anything is ambiguous/missing (e.g., missing DDL for a referenced table)\n- \"severity\": one of [\"LOW\",\"MEDIUM\",\"HIGH\",\"CRITICAL\"]\n- \"sql\": a Databricks SQL statement that returns ONLY violating rows (0 rows = pass)\n\n## SQL authoring rules (Databricks / Unity Catalog)\n\n- Use ONLY identifiers (tables, columns) that appear in CREATE TABLE/VIEW statements of the RELEVANT DDLs section.\n- Ignore identifiers from the EXAMPLES section.\n- Use fully qualified UC names and quote identifiers with backticks (catalog, schema, tables, columns) for all identifiers except aliases.\n- Return ONLY: identifying keys, minimal helpful context columns, and a final column named violation_reason (VARCHAR) explaining why each row failed.\n- Do NOT use SELECT *; list columns explicitly.\n- Be side-effect free (no DDL/DML).\n- Avoid non-determinism: no ORDER BY, LIMIT, RAND, or UDFs; use current_date() only if the rule requires time.\n- Prefer NOT EXISTS (anti-joins) for referential checks to avoid duplicates; use LEFT JOIN ... IS NULL only when strictly needed.\n- Normalize text comparisons with lower(trim(col)).\n- Interpret \"active\" flags with:\n  case when lower(trim(col)) in ('y','yes','true','1','active') then 'active'\n       when lower(trim(col)) in ('n','no','false','0','inactive') then 'inactive'\n       else 'unknown' end\n- Parse string dates via try_to_timestamp(col) or try_to_date(col); compare to current_date() for date rules.\n- For duplicates, use row_number() over (partition by <candidate key> order by <stable expression>) > 1.\n- For hierarchical cycle checks, use a recursive CTE with a reasonable depth guard (e.g., 100) and return the discovered path in violation_reason.\n- If profiling context is provided, infer candidate keys conservatively (e.g., approx_distinct ~= row_count implies uniqueness). If uncertain, say so in description and still provide a safe rule.\n\n## DATA vs METADATA guardrails (CRITICAL)\n\n- Row-level verification only: Never decide pass/fail from metadata/DDL flags (e.g., is_nullable, data_type). Always scan actual data rows in domain tables (e.g., WHERE `col` IS NULL).\n- Do NOT query metadata/system catalogs in FROM/JOIN (e.g., INFORMATION_SCHEMA.*, sys.*, pg_catalog.*, DESCRIBE/SHOW outputs) or schema-introspection/profiler views (tables with columns like table_name, column_name, data_type, is_nullable), unless the USER REQUEST explicitly asks to validate metadata.\n- Each rule MUST include at least one DOMAIN DATA TABLE (from RELEVANT DDLs) in the top-level FROM clause.\n- You may use metadata conceptually to infer keys/joins but it must not appear in the SQL or determine pass/fail.\n\n## Use of context\n\n- Use ONLY identifiers provided by RELEVANT DDLs.\n- If a referenced table is absent from RELEVANT DDLs, state the assumption explicitly in \"description\" and produce best-effort rules using tables that DO appear in RELEVANT DDLs. Do NOT fall back to metadata tables.\n- Favor keys/constraints suggested by profiling (uniqueness, nullability), but implement them as data scans.\n\n## Behavioral examples (for steering only; do NOT reuse identifiers)\n\nNOT OK (metadata-based null check):\n\n- Reads `is_nullable` from a schema/metadata table to claim null violations.\n\nOK (data-based null check):\n\n- SELECT `employee_id`, `skill_id`, 'proficiency is NULL' AS violation_reason\n  FROM `cat`.`sch`.`employee_skill`\n  WHERE `proficiency` IS NULL\n\nWhen generating your answer, respond ONLY with WELL-FORMED JSON containing the array of rules. NEVER return partial or invalid JSON. No code fences, markdown, or any text outside the JSON.",
  "rules": [
    {
      "name": "unique_business_ids",
      "sql": "SELECT ProductKey,\n       COUNT(*) AS duplicate_count,\n       'Duplicate ProductKey found' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct`\nGROUP BY ProductKey\nHAVING COUNT(*) > 1",
      "severity": "CRITICAL",
      "description": "Ensure that business IDs (ProductKey) in the dimproduct table are unique."
    },
    {
      "name": "required_attributes_present",
      "sql": "SELECT ProductKey,\n       EnglishProductName,\n       Color,\n       'Required attributes are missing' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct`\nWHERE EnglishProductName IS NULL\n  OR Color IS NULL",
      "severity": "HIGH",
      "description": "Verify that required attributes (EnglishProductName, Color) are not null in the dimproduct table."
    },
    {
      "name": "validate_size_and_color",
      "sql": "SELECT ProductKey,\n       SIZE,\n       Color,\n       'Invalid Size or Color value' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct`\nWHERE SIZE NOT IN ('Small',\n                   'Medium',\n                   'Large')\n  OR Color NOT IN ('Red',\n                   'Blue',\n                   'Green',\n                   'Black',\n                   'White')",
      "severity": "MEDIUM",
      "description": "Ensure that Size and Color values in dimproduct are within their respective domains."
    },
    {
      "name": "active_vs_discontinued_items",
      "sql": "SELECT ProductKey,\n       EndDate,\n       'Item is active but has an EndDate' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct`\nWHERE EndDate IS NOT NULL\n  AND EndDate <= current_date()",
      "severity": "MEDIUM",
      "description": "Distinguish active from discontinued items based on the EndDate column in dimproduct."
    },
    {
      "name": "subcategory_to_category_link",
      "sql": "SELECT s.ProductSubcategoryKey,\n       s.ProductCategoryKey,\n       'Subcategory not linked to a valid category' AS violation_reason\nFROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproductsubcategory` s\nLEFT JOIN `aigdqr-ragstoriches`.`adv_works_dw`.`dimproductcategory` c ON s.ProductCategoryKey = c.ProductCategoryKey\nWHERE c.ProductCategoryKey IS NULL",
      "severity": "HIGH",
      "description": "Confirm that each subcategory in dimproductsubcategory is correctly linked to a category in dimproductcategory."
    },
    {
      "name": "scd_period_consistency",
      "sql": "WITH period_check AS\n  (SELECT ProductKey,\n          StartDate,\n          EndDate,\n          ROW_NUMBER() OVER (PARTITION BY ProductKey\n                             ORDER BY StartDate) AS rn\n   FROM `aigdqr-ragstoriches`.`adv_works_dw`.`dimproduct`)\nSELECT a.ProductKey,\n       a.StartDate,\n       a.EndDate,\n       b.StartDate AS next_start_date,\n       'Overlapping SCD periods detected' AS violation_reason\nFROM period_check a\nJOIN period_check b ON a.ProductKey = b.ProductKey\nAND a.rn = b.rn - 1\nWHERE a.EndDate > b.StartDate",
      "severity": "CRITICAL",
      "description": "Ensure that SCD periods in dimproduct (StartDate and EndDate) are consistent and non-overlapping."
    }
  ]
}